const axios = require('axios');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const OpenAI = require('openai');

class AIService {
  constructor() {
    // Initialize AI clients
    this.perplexityClient = null;
    this.openaiClient = null;
    this.geminiClient = null;
    this.geminiModel = null;
  }

  // Initialize AI providers
  initializeProviders(useOwnKeys, perplexityApiKey, openaiApiKey, geminiApiKey) {
    console.log('ðŸ”§ Initializing AI providers...', {
      useOwnKeys,
      hasUserPerplexity: !!perplexityApiKey,
      hasUserOpenAI: !!openaiApiKey,
      hasUserGemini: !!geminiApiKey,
      hasEnvPerplexity: !!process.env.PERPLEXITY_API_KEY,
      hasEnvOpenAI: !!process.env.OPENAI_API_KEY,
      hasEnvGemini: !!process.env.GEMINI_API_KEY
    });

    if (useOwnKeys) {
      // Only use user-provided keys, ignore built-in keys completely
      this.perplexityClient = null;
      this.openaiClient = null;
      this.geminiClient = null;
      this.geminiModel = null;

      if (perplexityApiKey && this.isValidPerplexityKey(perplexityApiKey)) {
        this.perplexityClient = perplexityApiKey;
        console.log('âœ… User Perplexity client initialized');
      } else if (perplexityApiKey) {
        console.log('âŒ Invalid user Perplexity key format');
      }

      if (openaiApiKey && this.isValidOpenAIKey(openaiApiKey)) {
        this.openaiClient = new OpenAI({ apiKey: openaiApiKey });
        console.log('âœ… User OpenAI client initialized');
      } else if (openaiApiKey) {
        console.log('âŒ Invalid user OpenAI key format');
      }

      if (geminiApiKey && this.isValidGeminiKey(geminiApiKey)) {
        this.geminiClient = new GoogleGenerativeAI(geminiApiKey);
        this.geminiModel = this.geminiClient.getGenerativeModel({ model: "gemini-pro" });
        console.log('âœ… User Gemini client initialized (gemini-pro)');
      } else if (geminiApiKey) {
        console.log('âŒ Invalid user Gemini key format');
      }
    } else {
      // Use built-in keys only if user did not provide their own
      if (process.env.PERPLEXITY_API_KEY && this.isValidPerplexityKey(process.env.PERPLEXITY_API_KEY)) {
        this.perplexityClient = process.env.PERPLEXITY_API_KEY;
        console.log('âœ… Built-in Perplexity client initialized');
      } else {
        console.log('âŒ Built-in Perplexity key missing or invalid');
      }

      if (process.env.OPENAI_API_KEY && this.isValidOpenAIKey(process.env.OPENAI_API_KEY)) {
        this.openaiClient = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
        console.log('âœ… Built-in OpenAI client initialized');
      } else {
        console.log('âŒ Built-in OpenAI key missing or invalid');
      }

      if (process.env.GEMINI_API_KEY && this.isValidGeminiKey(process.env.GEMINI_API_KEY)) {
        this.geminiClient = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
        this.geminiModel = this.geminiClient.getGenerativeModel({ model: "gemini-1.5-flash" });
        console.log('âœ… Built-in Gemini client initialized');
      } else {
        console.log('âŒ Built-in Gemini key missing or invalid');
      }
    }
    
    console.log('ðŸ”§ Provider initialization complete:', {
      perplexity: !!this.perplexityClient,
      openai: !!this.openaiClient,
      gemini: !!this.geminiModel
    });
  }

  // Validate API keys
  isValidPerplexityKey(key) {
    return key && typeof key === 'string' && key.startsWith('pplx-') && key.length > 20;
  }

  isValidOpenAIKey(key) {
    return key && typeof key === 'string' && key.startsWith('sk-') && key.length > 20;
  }

  isValidGeminiKey(key) {
    return key && typeof key === 'string' && key.startsWith('AIza') && key.length > 20;
  }

  // Sanitize input
  sanitizeInput(str) {
    if (typeof str !== 'string') return '';
    return str.replace(/<script.*?>.*?<\/script>/gi, '').replace(/[<>]/g, '').trim();
  }

  // Sanitize output
  sanitizeOutput(str) {
    if (typeof str !== 'string') return '';
    let clean = str.replace(/<script.*?>.*?<\/script>/gi, '').replace(/[<>]/g, '');
    clean = clean.replace(/(OpenAI|Gemini|Perplexity|ChatGPT|Google AI|Anthropic|Claude|GPT-4|GPT-3|Bard|Llama|Meta AI|AI[- ]?powered|AI[- ]?generated|AI[- ]?assistant|AI[- ]?model|AI[- ]?system|AI[- ]?tool|AI[- ]?content|AI[- ]?response|AI[- ]?output|AI[- ]?suggestion|AI[- ]?tweet|AI[- ]?thread|AI\b|artificial intelligence|powered by AI|powered by artificial intelligence|by AI|using AI|created by AI|generated by AI|generated with AI|written by AI|written with AI|assistant|language model|machine learning model|machine learning)/gi, '');
    clean = clean.replace(/[\[\](){}=]/g, '');
    clean = clean.replace(/\s{2,}/g, ' ');
    return clean.trim();
  }

  // Generate tweet using Perplexity
  async generateWithPerplexity(prompt) {
    try {
      const response = await axios.post('https://api.perplexity.ai/chat/completions', {
        model: 'sonar-pro',
        messages: [{ role: 'user', content: prompt }],
      }, {
        headers: { 'Authorization': `Bearer ${this.perplexityClient}` }
      });
      return response.data.choices[0].message.content.trim();
    } catch (error) {
      console.error('Perplexity error:', error?.response?.data || error?.message || error);
      throw error;
    }
  }

  // Generate tweet using OpenAI
  async generateWithOpenAI(prompt) {
    try {
      const completion = await this.openaiClient.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "system",
            content: "You are a professional LinkedIn content creator. Create engaging, professional posts that add value to the business community. Keep posts under 3000 characters, use a professional tone, and encourage meaningful engagement."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 100,
        temperature: 0.8,
      });
      return completion.choices[0].message.content.trim();
    } catch (error) {
      console.error('OpenAI error:', error?.response?.data || error?.message || error);
      throw error;
    }
  }

  // Generate tweet using Gemini
  async generateWithGemini(prompt) {
    try {
      const result = await this.geminiModel.generateContent(
        `You are a professional LinkedIn content creator. Create engaging, professional posts that add value to the business community. Keep posts under 3000 characters, use a professional tone, and encourage meaningful engagement.\n\n${prompt}`
      );
      const response = result.response;
      return response.text().trim();
    } catch (error) {
      console.error('Gemini error:', error?.response?.data || error?.message || error);
      throw error;
    }
  }

  // Generate LinkedIn post using AI
  async generatePost({ prompt, useOwnKeys, perplexityApiKey, openaiApiKey, geminiApiKey, aiProviders, userId }) {
    const startTime = Date.now();
    let usedProvider = null;
    let attemptedProviders = [];
    
    try {
      console.log('ðŸš€ AIService.generatePost called with:', {
        prompt: prompt ? 'PROVIDED' : 'MISSING',
        useOwnKeys,
        aiProviders,
        userId,
        timestamp: new Date().toISOString()
      });

      this.initializeProviders(useOwnKeys, perplexityApiKey, openaiApiKey, geminiApiKey);
      
      console.log('âœ… Providers initialized. Available:', {
        perplexity: !!this.perplexityClient,
        openai: !!this.openaiClient,
        gemini: !!this.geminiModel
      });

      const sanitizedPrompt = this.sanitizeInput(prompt);
      const linkedinPrompt = `Create a professional LinkedIn post about: ${sanitizedPrompt}

Requirements:
- Keep it under 3000 characters
- Use a professional tone
- Include relevant hashtags
- Encourage engagement
- Add value to the LinkedIn community
- Use bullet points or numbered lists when appropriate
- End with a call-to-action

Format the response as a single LinkedIn post.`;

      const providerOrder = this.getProviderOrder(aiProviders);
      console.log('ðŸ“‹ Provider order:', providerOrder);
      
      for (const provider of providerOrder) {
        attemptedProviders.push(provider);
        try {
          console.log(`ðŸŽ¯ Attempting provider: ${provider.toUpperCase()}`);
          let result;
          const providerStartTime = Date.now();
          
          switch (provider) {
            case 'perplexity':
              result = await this.generateWithPerplexity(linkedinPrompt);
              break;
            case 'openai':
              result = await this.generateWithOpenAI(linkedinPrompt);
              break;
            case 'gemini':
              result = await this.generateWithGemini(linkedinPrompt);
              break;
            default:
              console.log(`âŒ Unknown provider: ${provider}`);
              continue;
          }
          
          if (result) {
            const providerTime = Date.now() - providerStartTime;
            usedProvider = provider;
            
            // Log successful generation
            console.log('ðŸŽ‰ CONTENT GENERATION SUCCESS:', {
              provider: provider.toUpperCase(),
              userId,
              keyType: useOwnKeys ? 'USER_PROVIDED' : 'BUILT_IN',
              responseTime: `${providerTime}ms`,
              contentLength: result.length,
              attemptedProviders,
              timestamp: new Date().toISOString()
            });

            const sanitizedResult = this.sanitizeOutput(result);
            
            // Return enhanced response with provider info
            return {
              content: sanitizedResult,
              metadata: {
                provider: provider.toUpperCase(),
                keyType: useOwnKeys ? 'User Keys' : 'Built-in Keys',
                responseTime: providerTime,
                contentLength: sanitizedResult.length,
                timestamp: new Date().toISOString(),
                attemptedProviders
              }
            };
          }
        } catch (error) {
          console.error(`âŒ ${provider.toUpperCase()} LinkedIn post generation failed:`, {
            provider,
            error: error.message,
            userId,
            keyType: useOwnKeys ? 'USER_PROVIDED' : 'BUILT_IN'
          });
          continue;
        }
      }
      
      // Log failure
      const totalTime = Date.now() - startTime;
      console.error('ðŸ’¥ ALL PROVIDERS FAILED:', {
        userId,
        keyType: useOwnKeys ? 'USER_PROVIDED' : 'BUILT_IN',
        attemptedProviders,
        totalTime: `${totalTime}ms`,
        timestamp: new Date().toISOString()
      });
      
      throw new Error('All AI providers failed to generate LinkedIn post');
    } catch (error) {
      console.error('LinkedIn post generation error:', error);
      throw error;
    }
  }

  // Generate image using OpenAI
  async generateImage({ prompt, useOwnKeys, openaiApiKey }) {
    try {
      let validOpenaiKey;
      
      if (useOwnKeys) {
        if (openaiApiKey && this.isValidOpenAIKey(openaiApiKey)) {
          validOpenaiKey = openaiApiKey;
        }
      } else {
        if (process.env.OPENAI_API_KEY && this.isValidOpenAIKey(process.env.OPENAI_API_KEY)) {
          validOpenaiKey = process.env.OPENAI_API_KEY;
        }
      }

      if (!validOpenaiKey) {
        return {
          success: false,
          message: "OpenAI API key required for image generation."
        };
      }

      const openaiClient = new OpenAI({ apiKey: validOpenaiKey });
      const cleanPrompt = this.sanitizeInput(prompt);
      const enhancedPrompt = `Create a high-quality, visually engaging image for social media. ${cleanPrompt}`;

      const response = await openaiClient.images.generate({
        prompt: enhancedPrompt,
        n: 1,
        size: "1024x1024",
        response_format: "url"
      });

      return {
        success: true,
        image: response.data[0].url,
        provider: "openai"
      };
    } catch (error) {
      console.error('Generate image error:', error);
      return {
        success: false,
        message: "Image generation failed",
        error: error.message
      };
    }
  }

  // Get provider order based on user selection or fallback
  getProviderOrder(aiProviders) {
    const availableProviders = [];
    
    if (this.perplexityClient) availableProviders.push('perplexity');
    if (this.openaiClient) availableProviders.push('openai');
    if (this.geminiModel) availableProviders.push('gemini');

    console.log('ðŸ“‹ Provider order calculation:', {
      aiProviders,
      aiProvidersLength: aiProviders?.length,
      availableProviders,
      availableCount: availableProviders.length
    });

    // If user specified providers and array is not empty, use them in order
    if (aiProviders && Array.isArray(aiProviders) && aiProviders.length > 0) {
      const filteredProviders = aiProviders.filter(provider => availableProviders.includes(provider));
      console.log('ðŸŽ¯ Using user-specified providers:', filteredProviders);
      return filteredProviders;
    }

    // Default fallback order: Use all available providers (Perplexity -> OpenAI -> Gemini)
    console.log('ðŸŽ¯ Using default provider order:', availableProviders);
    return availableProviders;
  }
}

module.exports = new AIService(); 